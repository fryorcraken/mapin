<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MapIn - Decentralized Pin Sharing</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            overflow: hidden;
        }

        #map {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100vh;
        }

        #connection-status {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            font-size: 14px;
            font-weight: 500;
            min-width: 200px;
        }

        #status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ccc;
            transition: background 0.3s ease;
        }

        #status-indicator.connecting {
            background: #ffa500;
            animation: pulse 1.5s infinite;
        }

        #status-indicator.connected {
            background: #4CAF50;
        }

        #status-indicator.disconnected {
            background: #f44336;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        #info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
            background: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            font-size: 13px;
            max-width: 300px;
        }

        #info-panel h3 {
            margin: 0 0 8px 0;
            font-size: 16px;
            color: #333;
        }

        #info-panel p {
            margin: 4px 0;
            color: #666;
        }

        .leaflet-popup-content {
            margin: 8px 12px;
            font-size: 13px;
        }

        .leaflet-popup-content strong {
            display: block;
            margin-bottom: 4px;
            color: #333;
        }

        #sync-indicator {
            font-size: 10px;
            transition: color 0.3s ease;
        }

        #sync-indicator.syncing {
            color: #ffa500;
            animation: pulse 1.5s infinite;
        }

        #sync-indicator.synced {
            color: #4CAF50;
        }

        #sync-indicator.warning {
            color: #f44336;
        }

        #context-menu {
            position: absolute;
            z-index: 10000;
            background: white;
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            padding: 4px 0;
            min-width: 150px;
        }

        #add-pin-option {
            padding: 10px 16px;
            cursor: pointer;
            font-size: 14px;
            color: #333;
            transition: background 0.2s ease;
        }

        #add-pin-option:hover {
            background: #f0f0f0;
        }

        #chat-window {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 350px;
            height: 450px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            z-index: 9999;
        }

        #chat-header {
            background: #4CAF50;
            color: white;
            padding: 12px 16px;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
        }

        #chat-title {
            font-size: 14px;
            font-weight: 500;
        }

        #chat-close {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            line-height: 20px;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        #chat-close:hover {
            opacity: 1;
        }

        #chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .chat-message {
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-width: 80%;
        }

        .chat-message.sent {
            align-self: flex-end;
        }

        .chat-message.received {
            align-self: flex-start;
        }

        .message-content {
            padding: 8px 12px;
            border-radius: 12px;
            word-wrap: break-word;
            font-size: 14px;
        }

        .chat-message.sent .message-content {
            background: #4CAF50;
            color: white;
        }

        .chat-message.received .message-content {
            background: #f0f0f0;
            color: #333;
        }

        .message-meta {
            font-size: 11px;
            color: #999;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .message-tick {
            display: inline-block;
            color: #4CAF50;
            font-size: 12px;
        }

        #chat-input-container {
            padding: 12px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        #chat-input {
            flex: 1;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 20px;
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
        }

        #chat-input:focus {
            border-color: #4CAF50;
        }

        #chat-send {
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
            flex-shrink: 0;
        }

        #chat-send:hover {
            background: #45a049;
        }

        #chat-send:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <div id="map"></div>

    <div id="connection-status">
        <div style="display: flex; align-items: center; gap: 10px;">
            <div id="status-indicator" class="disconnected"></div>
            <span id="status-text">Disconnected</span>
        </div>
        <div id="sync-status" style="display: block; margin-top: 10px; padding-top: 10px; border-top: 1px solid #e0e0e0;">
            <div style="display: flex; align-items: center; gap: 8px;">
                <span id="sync-indicator" class="syncing">●</span>
                <span id="sync-text">Initializing...</span>
            </div>
            <div id="sync-details" style="font-size: 11px; color: #666; margin-top: 4px;">Waiting for Waku...</div>
        </div>
    </div>

    <div id="info-panel">
        <h3>MapIn</h3>
        <p><strong>Right-click anywhere on the map to add a pin</strong></p>
        <p>Pins: <span id="pin-count">0</span></p>
        <p style="font-size: 11px; color: #999; margin-top: 8px;">
            Pins are synchronized via Waku network
        </p>
    </div>

    <!-- Custom Context Menu -->
    <div id="context-menu" style="display: none;">
        <div id="add-pin-option">Add pin here</div>
    </div>

    <!-- Chat Window -->
    <div id="chat-window" style="display: none;">
        <div id="chat-header">
            <div id="chat-title">Chat</div>
            <button id="chat-close">×</button>
        </div>
        <div id="chat-messages"></div>
        <div id="chat-input-container">
            <input type="text" id="chat-input" placeholder="Type a message...">
            <button id="chat-send">➤</button>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <!-- Protobuf.js -->
    <script src="https://cdn.jsdelivr.net/npm/protobufjs@7.2.5/dist/protobuf.min.js"></script>

    <!-- Waku SDK -->
    <script type="module">
        // Import Waku SDK
        import {
            createLightNode,
            ReliableChannel,
            HealthStatus
        } from 'https://unpkg.com/@waku/sdk@0.0.37-339e26e.0/bundle/index.js';

        // Global state
        let map;
        let pins = [];
        let markers = new Map(); // Store marker references by location key
        let wakuNode = null;
        let reliableChannel = null;
        let senderId = null;
        let pendingPinLocation = null; // Store location for context menu
        let currentChatChannel = null; // Current chat channel
        let currentChatLocation = null; // Current chat GPS location
        let chatMessageIds = new Map(); // Track message IDs for acknowledgments
        const STORAGE_KEY = 'mapin_pins';
        const CONTENT_TOPIC = '/mapin/1/pins/proto';
        const CHANNEL_NAME = 'mapin-global';

        // Define Protobuf message structure for pins
        const PinMessage = new protobuf.Type("PinMessage")
            .add(new protobuf.Field("latitude", 1, "double"))
            .add(new protobuf.Field("longitude", 2, "double"))
            .add(new protobuf.Field("timestamp", 3, "uint64"))
            .add(new protobuf.Field("isActive", 4, "bool"));

        // Define Protobuf message structure for chat messages
        const ChatMessage = new protobuf.Type("ChatMessage")
            .add(new protobuf.Field("text", 1, "string"))
            .add(new protobuf.Field("sender", 2, "string"))
            .add(new protobuf.Field("timestamp", 3, "uint64"));

        // Generate unique sender ID for this client
        function generateSenderId() {
            return 'user-' + Math.random().toString(36).substr(2, 9) + '-' + Date.now();
        }

        // Create marker icon from SVG
        function createMarkerIcon(color) {
            const fillColor = color === 'green' ? '#4CAF50' : '#2196F3';
            const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="25" height="41" viewBox="0 0 25 41">
                <path fill="${fillColor}" stroke="#fff" stroke-width="1.5" d="M12.5 0C5.6 0 0 5.6 0 12.5c0 8.4 12.5 28.5 12.5 28.5S25 20.9 25 12.5C25 5.6 19.4 0 12.5 0z"/>
                <circle fill="#fff" cx="12.5" cy="12.5" r="5"/>
            </svg>`;
            const iconUrl = 'data:image/svg+xml;base64,' + btoa(svg);

            return L.icon({
                iconUrl: iconUrl,
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34]
            });
        }

        // Initialize mapxc
        function initMap() {
            // Create map centered on London
            map = L.map('map').setView([51.505, -0.09], 13);

            // Add OpenStreetMap tiles
            L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
            }).addTo(map);

            // Add right-click listener for context menu
            map.on('contextmenu', onMapRightClick);

            // Hide context menu on left click or map movement
            map.on('click', hideContextMenu);
            map.on('drag', hideContextMenu);
            map.on('zoom', hideContextMenu);

            // Load existing pins from LocalStorage
            loadPinsFromStorage();
        }

        // Handle map right-click (show context menu)
        function onMapRightClick(e) {
            // Prevent default browser context menu
            L.DomEvent.preventDefault(e.originalEvent);

            // Store the location
            pendingPinLocation = {
                lat: e.latlng.lat,
                lng: e.latlng.lng,
                containerPoint: e.containerPoint
            };

            // Position and show context menu
            const contextMenu = document.getElementById('context-menu');
            contextMenu.style.left = e.containerPoint.x + 'px';
            contextMenu.style.top = e.containerPoint.y + 'px';
            contextMenu.style.display = 'block';

            console.log('Context menu shown at:', pendingPinLocation);
        }

        // Hide context menu
        function hideContextMenu() {
            const contextMenu = document.getElementById('context-menu');
            contextMenu.style.display = 'none';
            pendingPinLocation = null;
        }

        // Handle "Add pin here" click
        function handleAddPinClick() {
            if (!pendingPinLocation) {
                console.warn('No pending pin location');
                return;
            }

            const timestamp = Date.now();
            const pin = {
                latitude: pendingPinLocation.lat,
                longitude: pendingPinLocation.lng,
                timestamp: timestamp,
                isActive: false
            };

            addPin(pin);
            broadcastPin(pin);
            hideContextMenu();

            console.log('Pin added from context menu:', pin);
        }

        // Add pin to map and storage
        function addPin(pin) {
            // Check if pin already exists (deduplicate)
            const pinId = `${pin.latitude}_${pin.longitude}_${pin.timestamp}`;
            const exists = pins.some(p =>
                `${p.latitude}_${p.longitude}_${p.timestamp}` === pinId
            );

            if (exists) {
                console.log('Pin already exists, skipping:', pinId);
                return;
            }

            // Add to pins array
            pins.push(pin);

            // Create location key for marker storage
            const locationKey = `${pin.latitude.toFixed(5)}_${pin.longitude.toFixed(5)}`;

            // Choose marker color based on active status
            const markerColor = pin.isActive ? 'green' : 'blue';
            const markerIcon = createMarkerIcon(markerColor);

            // Create marker on map
            const marker = L.marker([pin.latitude, pin.longitude], { icon: markerIcon }).addTo(map);

            // Store marker reference
            markers.set(locationKey, { marker, pin });

            // Add popup with timestamp
            const date = new Date(pin.timestamp);
            const activeStatus = pin.isActive ? '<br><span style="color: green;">● Active</span>' : '';
            marker.bindPopup(`
                <strong>Pin</strong>${activeStatus}<br>
                Lat: ${pin.latitude.toFixed(5)}<br>
                Lng: ${pin.longitude.toFixed(5)}<br>
                Time: ${date.toLocaleString()}
            `);

            // Add click handler to open chat
            marker.on('click', () => {
                openChat(pin.latitude, pin.longitude);
            });

            // Save to LocalStorage
            savePinsToStorage();
            updatePinCount();

            console.log('Pin added:', pin, 'Active:', pin.isActive);
        }

        // Broadcast pin via Waku
        async function broadcastPin(pin) {
            if (!reliableChannel) {
                console.warn('Waku channel not ready, pin not broadcasted');
                return;
            }

            try {
                // Create Protobuf message
                const protoMessage = PinMessage.create({
                    latitude: pin.latitude,
                    longitude: pin.longitude,
                    timestamp: pin.timestamp,
                    isActive: pin.isActive || false
                });

                // Encode message
                const payload = PinMessage.encode(protoMessage).finish();

                // Send message and get message ID
                const messageId = reliableChannel.send(payload);
                console.log('Pin broadcasted via Waku (ID: ' + messageId + '):', pin);
            } catch (error) {
                console.error('Error broadcasting pin:', error);
            }
        }

        // Broadcast pin active status
        async function broadcastPinActive(lat, lng) {
            if (!reliableChannel) {
                console.warn('Waku channel not ready');
                return;
            }

            try {
                // Create message to mark pin as active
                const protoMessage = PinMessage.create({
                    latitude: lat,
                    longitude: lng,
                    timestamp: Date.now(),
                    isActive: true
                });

                // Encode message
                const payload = PinMessage.encode(protoMessage).finish();

                // Send message
                const messageId = reliableChannel.send(payload);
                console.log('Pin active status broadcasted (ID: ' + messageId + '):', lat, lng);
            } catch (error) {
                console.error('Error broadcasting pin active status:', error);
            }
        }

        // Open chat for a specific location
        async function openChat(lat, lng) {
            console.log('Opening chat for location:', lat, lng);

            currentChatLocation = { lat, lng };

            // Set chat title with GPS coordinates
            const chatTitle = document.getElementById('chat-title');
            chatTitle.textContent = `${lat.toFixed(5)}, ${lng.toFixed(5)}`;

            // Clear previous messages
            document.getElementById('chat-messages').innerHTML = '';
            chatMessageIds.clear();

            // Show chat window
            document.getElementById('chat-window').style.display = 'flex';
            document.getElementById('chat-input').focus();

            // Close existing chat channel
            if (currentChatChannel) {
                console.log('Closing previous chat channel');
                // Note: No cleanup method available in current API
            }

            // Create new chat channel for this location
            await createChatChannel(lat, lng);
        }

        // Close chat window
        function closeChat() {
            document.getElementById('chat-window').style.display = 'none';
            currentChatLocation = null;
            // Keep channel open for background messages
        }

        // Create chat channel for specific location
        async function createChatChannel(lat, lng) {
            if (!wakuNode) {
                console.error('Waku node not initialized');
                return;
            }

            try {
                // Create channel name from GPS coordinates (rounded to 5 decimals)
                const channelName = `chat-${lat.toFixed(5)}-${lng.toFixed(5)}`;
                const contentTopic = `/mapin/1/chat-${lat.toFixed(5)}-${lng.toFixed(5)}/proto`;

                console.log('Creating chat channel:', channelName);

                // Create encoder and decoder
                const encoder = wakuNode.createEncoder({ contentTopic });
                const decoder = wakuNode.createDecoder({ contentTopic });

                // Create reliable channel
                currentChatChannel = await ReliableChannel.create(
                    wakuNode,
                    channelName,
                    senderId,
                    encoder,
                    decoder
                );

                console.log('Chat channel created:', channelName);

                // Listen for incoming messages
                currentChatChannel.addEventListener('message-received', handleChatMessage);

                // Listen for acknowledgments
                currentChatChannel.addEventListener('message-acknowledged', (event) => {
                    const messageId = event.detail;
                    console.log('Chat message acknowledged:', messageId);
                    addMessageTick(messageId);
                });

                console.log('Chat channel ready');
            } catch (error) {
                console.error('Error creating chat channel:', error);
            }
        }

        // Send chat message
        async function sendChatMessage() {
            const input = document.getElementById('chat-input');
            const text = input.value.trim();

            if (!text || !currentChatChannel) {
                return;
            }

            try {
                // Create chat message
                const chatMsg = ChatMessage.create({
                    text: text,
                    sender: senderId,
                    timestamp: Date.now()
                });

                // Encode message
                const payload = ChatMessage.encode(chatMsg).finish();

                // Send message
                const messageId = currentChatChannel.send(payload);
                console.log('Chat message sent (ID: ' + messageId + '):', text);

                // Display message locally
                displayChatMessage(text, senderId, Date.now(), true, messageId);

                // Broadcast active status on main pin channel
                if (currentChatLocation) {
                    broadcastPinActive(currentChatLocation.lat, currentChatLocation.lng);
                }

                // Clear input
                input.value = '';
            } catch (error) {
                console.error('Error sending chat message:', error);
            }
        }

        // Handle incoming chat message
        function handleChatMessage(event) {
            try {
                const wakuMessage = event.detail;

                // Decode message
                const decoded = ChatMessage.decode(wakuMessage.payload);

                // Don't display our own messages again
                if (decoded.sender === senderId) {
                    return;
                }

                console.log('Chat message received:', decoded.text);

                // Display message
                displayChatMessage(
                    decoded.text,
                    decoded.sender,
                    Number(decoded.timestamp),
                    false,
                    null
                );
            } catch (error) {
                console.error('Error handling chat message:', error);
            }
        }

        // Display chat message in UI
        function displayChatMessage(text, sender, timestamp, isSent, messageId) {
            const messagesContainer = document.getElementById('chat-messages');

            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${isSent ? 'sent' : 'received'}`;

            if (messageId) {
                messageDiv.dataset.messageId = messageId;
            }

            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.textContent = text;

            const metaDiv = document.createElement('div');
            metaDiv.className = 'message-meta';

            const time = new Date(timestamp);
            metaDiv.textContent = time.toLocaleTimeString();

            if (isSent && messageId) {
                const tickSpan = document.createElement('span');
                tickSpan.className = 'message-tick';
                tickSpan.style.display = 'none';
                tickSpan.textContent = '✓';
                metaDiv.appendChild(tickSpan);

                // Store message ID for acknowledgment tracking
                chatMessageIds.set(messageId, messageDiv);
            }

            messageDiv.appendChild(contentDiv);
            messageDiv.appendChild(metaDiv);
            messagesContainer.appendChild(messageDiv);

            // Scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // Add tick to acknowledged message
        function addMessageTick(messageId) {
            const messageDiv = chatMessageIds.get(messageId);
            if (messageDiv) {
                const tick = messageDiv.querySelector('.message-tick');
                if (tick) {
                    tick.style.display = 'inline-block';
                }
            }
        }

        // Handle incoming pin from Waku
        function handleIncomingMessage(event) {
            try {
                const wakuMessage = event.detail;

                // Decode Protobuf message
                const decoded = PinMessage.decode(wakuMessage.payload);

                // Convert to plain object
                const pin = {
                    latitude: decoded.latitude,
                    longitude: decoded.longitude,
                    timestamp: Number(decoded.timestamp),
                    isActive: decoded.isActive || false
                };

                // Validate pin data
                if (!pin.latitude || !pin.longitude || !pin.timestamp) {
                    console.warn('Invalid pin data received:', pin);
                    return;
                }

                console.log('Pin received via Waku:', pin, 'Active:', pin.isActive);

                // Check if this is an active status update for existing pin
                const locationKey = `${pin.latitude.toFixed(5)}_${pin.longitude.toFixed(5)}`;
                const existingMarker = markers.get(locationKey);

                if (existingMarker && pin.isActive) {
                    // Update existing marker to active
                    updatePinActiveStatus(pin.latitude, pin.longitude, true);
                } else {
                    // Add new pin
                    addPin(pin);
                }
            } catch (error) {
                console.error('Error handling incoming message:', error);
            }
        }

        // Update pin active status
        function updatePinActiveStatus(lat, lng, isActive) {
            const locationKey = `${lat.toFixed(5)}_${lng.toFixed(5)}`;
            const markerData = markers.get(locationKey);

            if (!markerData) {
                console.warn('No marker found for location:', locationKey);
                return;
            }

            // Update pin object
            markerData.pin.isActive = isActive;

            // Update marker icon
            const markerColor = isActive ? 'green' : 'blue';
            const newIcon = createMarkerIcon(markerColor);

            markerData.marker.setIcon(newIcon);

            // Update popup content
            const date = new Date(markerData.pin.timestamp);
            const activeStatus = isActive ? '<br><span style="color: green;">● Active</span>' : '';
            markerData.marker.setPopupContent(`
                <strong>Pin</strong>${activeStatus}<br>
                Lat: ${lat.toFixed(5)}<br>
                Lng: ${lng.toFixed(5)}<br>
                Time: ${date.toLocaleString()}
            `);

            // Update in pins array
            const pinIndex = pins.findIndex(p =>
                p.latitude.toFixed(5) === lat.toFixed(5) &&
                p.longitude.toFixed(5) === lng.toFixed(5)
            );
            if (pinIndex !== -1) {
                pins[pinIndex].isActive = isActive;
            }

            // Save to LocalStorage
            savePinsToStorage();

            console.log('Pin active status updated:', lat, lng, 'Active:', isActive);
        }

        // Load pins from LocalStorage
        function loadPinsFromStorage() {
            try {
                const stored = localStorage.getItem(STORAGE_KEY);
                if (stored) {
                    const storedPins = JSON.parse(stored);
                    console.log(`Loaded ${storedPins.length} pins from LocalStorage`);

                    // Clear current pins array
                    pins = [];

                    // Add all stored pins to map using addPin function
                    storedPins.forEach(pin => {
                        // Create location key
                        const locationKey = `${pin.latitude.toFixed(5)}_${pin.longitude.toFixed(5)}`;

                        // Skip if already exists in markers
                        if (markers.has(locationKey)) {
                            return;
                        }

                        // Choose marker color based on active status
                        const markerColor = pin.isActive ? 'green' : 'blue';
                        const markerIcon = createMarkerIcon(markerColor);

                        // Create marker on map
                        const marker = L.marker([pin.latitude, pin.longitude], { icon: markerIcon }).addTo(map);

                        // Store marker reference
                        markers.set(locationKey, { marker, pin });

                        // Add popup
                        const date = new Date(pin.timestamp);
                        const activeStatus = pin.isActive ? '<br><span style="color: green;">● Active</span>' : '';
                        marker.bindPopup(`
                            <strong>Pin</strong>${activeStatus}<br>
                            Lat: ${pin.latitude.toFixed(5)}<br>
                            Lng: ${pin.longitude.toFixed(5)}<br>
                            Time: ${date.toLocaleString()}
                        `);

                        // Add click handler to open chat
                        marker.on('click', () => {
                            openChat(pin.latitude, pin.longitude);
                        });

                        // Add to pins array
                        pins.push(pin);
                    });

                    updatePinCount();
                }
            } catch (error) {
                console.error('Error loading pins from storage:', error);
            }
        }

        // Save pins to LocalStorage
        function savePinsToStorage() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(pins));
            } catch (error) {
                console.error('Error saving pins to storage:', error);
            }
        }

        // Update pin count display
        function updatePinCount() {
            document.getElementById('pin-count').textContent = pins.length;
        }

        // Update connection status UI
        function updateConnectionStatus(status, text) {
            const indicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');

            indicator.className = status;
            statusText.textContent = text;
        }

        // Update sync status UI
        function updateSyncStatus(state, detail) {
            console.log('updateSyncStatus called:', state, detail);
            const syncStatus = document.getElementById('sync-status');
            const syncIndicator = document.getElementById('sync-indicator');
            const syncText = document.getElementById('sync-text');
            const syncDetails = document.getElementById('sync-details');

            if (!syncStatus) {
                console.error('sync-status element not found!');
                return;
            }

            if (state === 'syncing') {
                syncStatus.style.display = 'block';
                syncIndicator.className = 'syncing';
                syncText.textContent = 'Syncing';

                if (detail) {
                    const parts = [];
                    parts.push(`Received: ${detail.received || 0}`);
                    if (detail.missing > 0) {
                        parts.push(`Missing: ${detail.missing}`);
                    }
                    if (detail.lost > 0) {
                        parts.push(`Lost: ${detail.lost}`);
                    }
                    syncDetails.innerHTML = parts.join('<br>');
                } else {
                    syncDetails.innerHTML = '';
                }
                console.log('Sync status set to display: block');
            } else if (state === 'synced') {
                syncIndicator.className = 'synced';
                syncText.textContent = 'Synced';

                if (detail) {
                    const parts = [];
                    parts.push(`Received: ${detail.received || 0}`);
                    if (detail.missing > 0) {
                        parts.push(`Missing: ${detail.missing}`);
                    }
                    if (detail.lost > 0) {
                        parts.push(`Lost: ${detail.lost}`);
                        syncIndicator.className = 'warning';
                    }
                    syncDetails.innerHTML = parts.join('<br>');
                } else {
                    syncDetails.innerHTML = '';
                }

                // Keep sync status visible - do not auto-hide
            } else if (state === 'hidden') {
                // Keep visible even when hidden state is requested
                syncStatus.style.display = 'block';
            }
        }

        // Initialize Waku
        async function initWaku() {
            updateConnectionStatus('connecting', 'Connecting...');

            try {
                console.log('Initializing Waku light node...');

                // Create light node with default bootstrap
                wakuNode = await createLightNode({ defaultBootstrap: true });
                console.log('Waku node created');

                // Create encoder and decoder for the content topic
                const encoder = wakuNode.createEncoder({ contentTopic: CONTENT_TOPIC });
                const decoder = wakuNode.createDecoder({ contentTopic: CONTENT_TOPIC });
                console.log('Encoder and decoder created');

                // Generate unique sender ID for this client
                senderId = generateSenderId();
                console.log('Sender ID:', senderId);

                // Create reliable channel
                reliableChannel = await ReliableChannel.create(
                    wakuNode,
                    CHANNEL_NAME,
                    senderId,
                    encoder,
                    decoder
                );

                console.log('Reliable channel created');
                updateConnectionStatus('connected', 'Connected');

                // Show initial sync status
                updateSyncStatus('syncing', { received: 0, missing: 0, lost: 0 });

                // Listen for incoming messages
                reliableChannel.addEventListener('message-received', handleIncomingMessage);

                // Listen for message status events
                reliableChannel.addEventListener('message-sent', (event) => {
                    console.log('Message sent successfully:', event.detail);
                });

                reliableChannel.addEventListener('message-acknowledged', (event) => {
                    console.log('Message acknowledged:', event.detail);
                });

                reliableChannel.addEventListener('sending-message-irrecoverable-error', (event) => {
                    console.error('Irrecoverable error sending message:', event.detail);
                });

                // Monitor sync status
                reliableChannel.syncStatus.addEventListener('syncing', (event) => {
                    const { received, missing, lost } = event.detail;
                    console.log(`Syncing: ${received} received, ${missing} missing, ${lost} lost`);
                    updateSyncStatus('syncing', event.detail);
                });

                reliableChannel.syncStatus.addEventListener('synced', (event) => {
                    const { received, missing, lost } = event.detail;
                    console.log(`Synced: ${received} received, ${missing} missing, ${lost} lost`);

                    if (lost > 0) {
                        console.warn(`Warning: ${lost} messages permanently lost`);
                    }

                    updateSyncStatus('synced', event.detail);
                });

                console.log('Sync status monitoring enabled');

                // Monitor network health
                wakuNode.events.addEventListener('waku:health', (event) => {
                    const health = event.detail;
                    console.log('Network health:', health);

                    if (health === HealthStatus.SufficientlyHealthy) {
                        updateConnectionStatus('connected', 'Connected');
                    } else if (health === HealthStatus.MinimallyHealthy) {
                        updateConnectionStatus('connecting', 'Degraded connection');
                    } else {
                        updateConnectionStatus('disconnected', 'Disconnected');
                    }
                });

                console.log('Waku initialization complete');
            } catch (error) {
                console.error('Error initializing Waku:', error);
                updateConnectionStatus('disconnected', 'Failed to connect');

                // Retry after 10 seconds
                setTimeout(() => {
                    console.log('Retrying Waku connection...');
                    initWaku();
                }, 10000);
            }
        }

        // Initialize app
        window.addEventListener('DOMContentLoaded', () => {
            console.log('MapIn starting...');

            // Add click handler for context menu option
            document.getElementById('add-pin-option').addEventListener('click', handleAddPinClick);

            // Hide context menu when clicking outside
            document.addEventListener('click', (e) => {
                const contextMenu = document.getElementById('context-menu');
                if (e.target.id !== 'add-pin-option' && !contextMenu.contains(e.target)) {
                    hideContextMenu();
                }
            });

            // Chat window event listeners
            document.getElementById('chat-close').addEventListener('click', closeChat);

            // Send message on Enter key
            document.getElementById('chat-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendChatMessage();
                }
            });

            // Send message on button click
            document.getElementById('chat-send').addEventListener('click', sendChatMessage);

            initMap();
            initWaku();
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', async () => {
            if (wakuNode) {
                try {
                    console.log('Stopping Waku node...');
                    await wakuNode.stop();
                } catch (error) {
                    console.error('Error stopping Waku node:', error);
                }
            }
        });
    </script>
</body>
</html>
